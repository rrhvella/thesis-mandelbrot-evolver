using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using NEATSpacesLibrary.CPPNNEAT;
using System.Numerics;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;

namespace MandelbrotCPPNNEAT
{
    public class MandelbrotCPPNNEATPhenome 
    {
        /// <summary>
        /// The magnitude of z at which an iterative function is determined to tend to infinity.
        /// </summary>
        private const double ESCAPE_MAGNITUDE = 2;

        /// <summary>
        /// The offset, in bits, from the end of an ARGB pixel to the end of the alpha portion.
        /// </summary>
        private const int ALPHA_OFFSET = 24;

        /// <summary>
        /// The offset, in bits, from the end of an ARGB pixel to the end of the red portion.
        /// </summary>
        private const int RED_OFFSET = 16;

        /// <summary>
        /// The offset, in bits, from the end of an ARGB pixel to the end of the green portion.
        /// </summary>
        private const int GREEN_OFFSET = 8;

        /// <summary>
        /// The offset, in bits, from the end of an ARGB pixel to the end of the blue portion.
        /// </summary>
        private const int BLUE_OFFSET = 0;

        /// <summary>
        /// The number of bytes in an ARGB pixel.
        /// </summary>
        private const int BYTES_PER_INT = 4;

        /// <summary>
        /// The colours corresponding to the main hues displayed in an image.
        /// </summary>
        private static readonly Color[] BASE_COLOURS = new Color[] { 
            Color.FromArgb(255, 221, 0),
            Color.FromArgb(161, 255, 0),
            Color.FromArgb(0, 33, 225),
            Color.FromArgb(93, 0, 225)
        };

        /// <summary>
        /// The network on which the iterative function is based.
        /// </summary>
        private CPPNNetwork network;

        /// <summary>
        /// The complex number at the top-left corner of the view.
        /// </summary>
        private Complex viewPosition;

        /// <summary>
        /// The distance, in the complex plane, between the two corners of each side of the view.
        /// </summary>
        private double viewScale;

        /// <summary>
        /// </summary>
        /// <param name="viewNetwork">The network on which the iterative function is based.</param>
        /// <param name="viewPosition">The complex number at the top-left corner of the view.</param>
        /// <param name="viewScale">The distance, in the complex plane, between the two corners of each 
        /// side of the view.</param>
        public MandelbrotCPPNNEATPhenome(CPPNNetwork viewNetwork, Complex viewPosition, double viewScale)
        {
            this.network = viewNetwork;
            this.viewPosition = viewPosition;
            this.viewScale = viewScale;
        }

        /// <summary>
        /// Returns a 2D image of a view of the complex plane showing the Mandelbrot set generated by the network
        /// corresponding to this phenome.
        /// </summary>
        /// <param name="viewWidth">The resolution width, in pixels, of the fractal views. Resolution here refers to 
        /// the number of complex numbers sampled within a view.</param>
        /// <param name="viewHeight">The resolution height, in pixels, of the fractal views. Resolution here refers to 
        /// the number of complex numbers sampled within a view.</param>
        /// <param name="iterationNumberLimit">The limit to the number of iterations that a network is destined before
        /// it is determined to be bounded. </param>
        /// <returns></returns>
        public Bitmap GetImage(int viewWidth, int viewHeight, int iterationNumberLimit)
        {
            //Use the iteration number at each pixel location to colour them.
            Bitmap fractalImage = new Bitmap(viewWidth, viewHeight);

            var drawingBuffer = fractalImage.LockBits(new Rectangle(0, 0, viewWidth, viewHeight),
                                                ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);

            foreach(var tup in GetIterationNumbers(viewWidth, viewHeight, iterationNumberLimit))
            {
                //Update colours by writing the pixels directly.
                Marshal.WriteInt32(drawingBuffer.Scan0 + drawingBuffer.Stride * tup.Y + tup.X * BYTES_PER_INT, 
                                ToColour(tup.IterationNumber, iterationNumberLimit, tup.Z));
            }

            fractalImage.UnlockBits(drawingBuffer);

            return fractalImage;
        }

        /// <summary>
        /// Stores the iteration number, and value of z, for a pixel location.
        /// </summary>
        private struct IterationNumberTuple
        {
            /// <summary>
            /// The x location of the pixel.
            /// </summary>
            public int X;
            /// <summary>
            /// The y location of the pixel.
            /// </summary>
            public int Y;
            /// <summary>
            /// The iteration number of the pixel.
            /// </summary>
            public int IterationNumber;
            /// <summary>
            /// The value of z once a pixel has been tested.
            /// </summary>
            public Complex Z;

            /// <summary>
            /// </summary>
            /// <param name="x">The x location of the pixel.</param>
            /// <param name="y">The y location of the pixel.</param>
            /// <param name="iterationNumber">The iteration number of the pixel.</param>
            /// <param name="z">The value of z once a pixel has been tested.</param>
            public IterationNumberTuple(int x, int y, int iterationNumber, Complex z)
            {
                this.X = x;
                this.Y = y;
                this.IterationNumber = iterationNumber;
                this.Z = z;
            }
        }

        /// <summary>
        /// Generates the iteration number for each pixel at the given resolution, and up to the given iteration 
        /// number limit.
        /// </summary>
        /// <param name="viewWidth"></param>
        /// <param name="viewHeight"></param>
        /// <param name="iterationNumberLimit"></param>
        /// <returns></returns>
        private IEnumerable<IterationNumberTuple> GetIterationNumbers(int viewWidth, int viewHeight, 
                                                                    int iterationNumberLimit)
        {
            network.Reset();

            foreach (var x in Enumerable.Range(0, viewWidth))
            {
                foreach (var y in Enumerable.Range(0, viewHeight))
                {
                    var c = viewPosition + 
                                (new Complex((double)x / viewWidth, (double)y / viewHeight) * viewScale);

                    var z = Complex.Zero;
                    var currentMagnitude = z.Magnitude;

                    int i = 0;

                    for (; i < iterationNumberLimit && currentMagnitude < ESCAPE_MAGNITUDE; i++)
                    {
                        z = network.GetActivation(new Complex[] { z, c });
                        currentMagnitude = z.Magnitude;
                    }

                    yield return new IterationNumberTuple(x, y, i, z);
                }
            }
        }

        /// <summary>
        /// Returns an ARGB pixel based on the iteration number, iteration number limit, and value of z.
        /// </summary>
        /// <param name="iterationNumber"></param>
        /// <param name="iterationNumberLimit"></param>
        /// <param name="z"></param>
        /// <returns></returns>
        private int ToColour(int iterationNumber, int iterationNumberLimit, Complex z)
        {
            var shadingAdjustment = Math.Log(Math.Log(z.Magnitude), 2);
            var normalisedIterationNumber = iterationNumber / (double)iterationNumberLimit;

            var brightness = 1 - normalisedIterationNumber - shadingAdjustment / iterationNumberLimit;
            var baseColor = BASE_COLOURS[(int)Math.Round(normalisedIterationNumber * (BASE_COLOURS.Length - 1))];

            var r = (int)(baseColor.R * brightness);
            var g = (int)(baseColor.G * brightness);
            var b = (int)(baseColor.B * brightness);

            return 255 << ALPHA_OFFSET | r << RED_OFFSET | 
                    g << GREEN_OFFSET | b << BLUE_OFFSET;
        }

    }
}
