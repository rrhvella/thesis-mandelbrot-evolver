using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using NEATSpacesLibrary.Extensions;
using NEATSpacesLibrary.GeneticAlgorithms;
using System.Numerics;

namespace NEATSpacesLibrary.CPPNNEAT
{
    /// <summary>
    /// Base class for genetic algorithms based on CPPN-NEAT.
    /// </summary>
    /// <typeparam name="GenomeType">The genome type. </typeparam>
    /// <typeparam name="GType">The type of the genome genetic sequence. </typeparam>
    /// <typeparam name="PType">The type of the phenome. </typeparam>
    public class BaseCPPNNEATGA<GenomeType, GType, PType> :
        BaseSpeciatedGA<GenomeType, GType, PType>
        where GenomeType : CPPNNEATGenome<GType, PType>, new()
        where GType : CPPNNEATGeneCollection, new()
    {

        /// <summary>
        /// Maps a pair of neurons to the innovation number of the link between them.
        /// </summary>
        private Dictionary<Tuple<CPPNNEATNeuronGene, CPPNNEATNeuronGene>, int> edgeInnovationNumberMap;
        /// <summary>
        /// Maps a link's innovation number to the pair of neurons it joins.
        /// </summary>
        private Dictionary<int, Tuple<CPPNNEATNeuronGene, CPPNNEATNeuronGene>> edgeMap;
        /// <summary>
        /// Maps a neuron's innovation number to that neuron.
        /// </summary>
        private Dictionary<int, CPPNNEATNeuronGene> hiddenNeuronMap;

        /// <summary>
        /// The list of function factories used to generate the activation functions for the output and hidden neurons.        
        /// </summary>
        public IList<Func<CPPNNEATActivationFunction>> CanonicalFunctionList
        {
            get;
            private set;
        }

        /// <summary>
        /// </summary>
        /// <param name="numberOfInputs">The number of inputs for the networks generated by this algorithm.</param>
        /// <param name="populationSize">The number of individuals in the population.</param>
        /// <param name="scoreFunction">The function used to determine the fitness of an individual.</param>
        /// <param name="canonicalFunctionList">The list of function factories used to generate the activation functions 
        /// for the output and hidden neurons.</param>
        /// <param name="feedForwardOnly">If true, forces the algorithm to only generate feed forward networks. </param>
        public BaseCPPNNEATGA(int numberOfInputs, int populationSize, Func<GenomeType, double> scoreFunction,
                        List<Func<CPPNNEATActivationFunction>> canonicalFunctionList, 
                        bool feedForwardOnly)
            : this(numberOfInputs, populationSize, scoreFunction, canonicalFunctionList, null, feedForwardOnly) 
        {
        }

        /// <summary>
        /// </summary>
        /// <param name="numberOfInputs">The number of inputs for the networks generated by this algorithm.</param>
        /// <param name="populationSize">The number of individuals in the population.</param>
        /// <param name="scoreFunction">The function used to determine the fitness of an individual.</param>
        /// <param name="canonicalFunctionList">The list of function factories used to generate the activation functions 
        /// for the hidden neurons.</param>
        /// <param name="outputActivationFunction">The function factory used to generate the output activation function. </param>
        /// <param name="feedForwardOnly">If true, forces the algorithm to only generate feed forward networks. </param>
        public BaseCPPNNEATGA(int numberOfInputs, int populationSize, Func<GenomeType, double> scoreFunction,
                        List<Func<CPPNNEATActivationFunction>> canonicalFunctionList, 
                        Func<CPPNNEATActivationFunction> outputActivationFunction,
                        bool feedForwardOnly): base(populationSize, scoreFunction)
        {
            //Assert that the number of inputs is greater than 0.
            if (numberOfInputs < 1)
            {
                throw new ApplicationException("Numbers of inputs cannot be less than 1.");
            }

            //Initialise members.
            this.NumberOfInputs = numberOfInputs;
            this.CanonicalFunctionList = canonicalFunctionList;

            this.edgeInnovationNumberMap = new Dictionary<Tuple<CPPNNEATNeuronGene, CPPNNEATNeuronGene>, int>();
            this.hiddenNeuronMap = new Dictionary<int, CPPNNEATNeuronGene>();
            this.edgeMap = new Dictionary<int, Tuple<CPPNNEATNeuronGene, CPPNNEATNeuronGene>>();

            this.defaultNeuronGenes = new List<CPPNNEATNeuronGene>();
            this.defaultLinkGenes = new List<CPPNNEATLinkGene>();

            this.FeedForwardOnly = feedForwardOnly;

            this.IterationComplete += new EventHandler<IterationEventArgs>(CPPNNEATGA_IterationComplete); 

            //Build initial architecture based on the number of inputs.
            var outputGene = new CPPNNEATNeuronGene(neuronInnovationNumber++, 1, CPPNNeuronType.Output, 
                                                    (outputActivationFunction == null)? 
                                                        canonicalFunctionList.RandomSingle()() : outputActivationFunction());


            var currentGene = new CPPNNEATNeuronGene(neuronInnovationNumber++, 0, CPPNNeuronType.Bias, null);
            defaultNeuronGenes.Add(currentGene);
            defaultLinkGenes.Add(new CPPNNEATLinkGene(GetEdgeInnovationNumber(currentGene, outputGene), currentGene, 
                                                        outputGene, 0));

            foreach (var i in Enumerable.Range(0, numberOfInputs))
            {
                currentGene = new CPPNNEATNeuronGene(neuronInnovationNumber++, 0, CPPNNeuronType.Input, null);

                defaultNeuronGenes.Add(currentGene);
                defaultLinkGenes.Add(new CPPNNEATLinkGene(GetEdgeInnovationNumber(currentGene, outputGene), currentGene, 
                                                            outputGene, 0));
            }

            defaultNeuronGenes.Add(outputGene);
        }

        /// <summary>
        /// The number of inputs for the networks generated by this algorithm.
        /// </summary>
        public int NumberOfInputs
        {
            get;
            private set;
        }

        /// <summary>
        /// Determines the rate at which weights are modified during mutation.
        /// </summary>
        public double WeightMutationRate
        {
            get;
            set;
        }

        /// <summary>
        /// Determines the rate at which new neurons are added during mutation.
        /// </summary>
        public double NewNeuronRate
        {
            get;
            set;
        }

        /// <summary>
        /// Determines the rate at which new links are added during mutation.
        /// </summary>
        public double NewLinkRate
        {
            get;
            set;
        }

        /// <summary>
        /// For a child genome, this determines the probability of a link gene being disabled if it is disabled for a parent 
        /// genome.
        /// </summary>
        public double DisableGeneRate 
        {
            get;
            set;
        }

        /// <summary>
        /// Determines the rate at which mutated weights are perturbed as opposed to reinitialised.
        /// </summary>
        public double WeightPertubationRate
        {
            get;
            set;
        }

        /// <summary>
        /// The rate at which parent weights are averaged, as opposed to selecting one or the other.
        /// </summary>
        public double MateByAveragingRate
        {
            get;
            set;
        }

        /// <summary>
        /// The maximum magnitude of the value by which a weight is modified during perturbation.
        /// </summary>
        public double MaxPerturbation
        {
            get;
            set;
        }
        
        /// <summary>
        /// The maximum magnitude each weight is initialised to.
        /// </summary>
        public double MaxWeight
        {
            get;
            set;
        }

        /// <summary>
        /// The weight of the number of excess genes on the compatibility distance. 
        /// </summary>
        public double ExcessGenesWeight
        {
            get;
            set;
        }

        /// <summary>
        /// The weight of the number of disjoint genes on the compatibility distance. 
        /// </summary>
        public double DisjointGenesWeight
        {
            get;
            set;
        }

        /// <summary>
        /// The weight of the average difference in link weights on the compatibility distance. 
        /// </summary>
        public double MatchingGenesWeight
        {
            get;
            set;
        }

        /// <summary>
        /// The weight of the average difference in function counts on the compatibility distance. 
        /// </summary>
        public double FunctionDifferenceWeight
        {
            get;
            set;
        }

        /// <summary>
        /// Determines the number of generations before the link cache is cleared. The link cache maps pairs of neurons to 
        /// the innovation number of their link <seealso cref="edgeInnovationNumberMap"/>, this forces similar innovations to share
        /// the same innovation number and prevents the innovation number from exploding.
        /// </summary>
        public int IterationsToClearLinkCache
        {
            get;
            set;
        }
        
        /// <summary>
        /// The neurons in the initial architecture of all individuals.
        /// </summary>
        private List<CPPNNEATNeuronGene> defaultNeuronGenes;
        public IList<CPPNNEATNeuronGene> DefaultNeuronGenes
        {
            get
            {
                return defaultNeuronGenes.AsReadOnly();
            }
            private set
            {
                defaultNeuronGenes = (List<CPPNNEATNeuronGene>)value;
            }
        }

        /// <summary>
        /// The links in the initial architecture of all individuals.
        /// </summary>
        private List<CPPNNEATLinkGene> defaultLinkGenes;
        public IList<CPPNNEATLinkGene> DefaultLinkGenes
        {
            get
            {
                return defaultLinkGenes.AsReadOnly();
            }
            private set
            {
                defaultLinkGenes = (List<CPPNNEATLinkGene>)value;
            }
        }

        /// <summary>
        /// Returns a random weight <seealso cref="MaxWeight"/>.
        /// </summary>
        public Complex GetRandomWeight()
        {
            return MathExtensions.ComplexRandom(-MaxWeight, MaxWeight);
        }


        /// <summary>
        /// The innovation number of the next link to be created.
        /// </summary>
        private int edgeInnovationNumber = 0;

        /// <summary>
        /// The innovation number of the next neuron to be created.
        /// </summary>
        private int neuronInnovationNumber = 0;

        /// <summary>
        /// If true, forces the algorithm to only generate feed forward networks.
        /// </summary>
        public bool FeedForwardOnly
        {
            get;
            private set;
        }

        /// <summary>
        /// Handles the event fired when an iteration is complete.
        /// </summary>
        public void CPPNNEATGA_IterationComplete(object sender, IterationEventArgs e)
        {
            //If the required number of iterations have transpired, clear the link cache.
            if (IterationsToClearLinkCache != 0 && e.IterationNumber % IterationsToClearLinkCache == 0)
            {
                edgeInnovationNumberMap.Clear();
            }
        }

        /// <summary>
        /// Returns the innovation number for the link between the given neurons.
        /// </summary>
        public int GetEdgeInnovationNumber(CPPNNEATNeuronGene from, CPPNNEATNeuronGene to)
        {
            //If the neuron pair is present in the cache, return that as the innovation number. 
            //Otherwise, generate a new one, cache it, and return it.
            var key = new Tuple<CPPNNEATNeuronGene, CPPNNEATNeuronGene>(from, to);

            if (!edgeInnovationNumberMap.ContainsKey(key))
            {
                edgeInnovationNumberMap[key] = edgeInnovationNumber;
                edgeMap[edgeInnovationNumber] = key;

                edgeInnovationNumber++;
            }

            return edgeInnovationNumberMap[key];
        }

        /// <summary>
        /// Returns the hidden neuron corresponding to the given innovation number.
        /// </summary>
        public CPPNNEATNeuronGene GetHiddenNeuron(int innovationNumber)
        {
            //If we already know about this innovation number, return the neuron. Otherwise, create the neuron and store it, 
            //before returning it.
            if (!hiddenNeuronMap.ContainsKey(innovationNumber))
            {
                var edge = edgeMap[innovationNumber];
                var level = (edge.Item1.Level + edge.Item2.Level) / 2;

                hiddenNeuronMap[innovationNumber] = new CPPNNEATNeuronGene(neuronInnovationNumber++, level, CPPNNeuronType.Hidden, 
                                                                    CanonicalFunctionList.RandomSingle()());
            }

            return hiddenNeuronMap[innovationNumber];
        }
    }
}
